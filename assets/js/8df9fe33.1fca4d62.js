"use strict";(self.webpackChunksemaphore_spec=self.webpackChunksemaphore_spec||[]).push([[604],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=i.createContext({}),h=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=h(e.components);return i.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=h(n),d=r,m=c["".concat(s,".").concat(d)]||c[d]||u[d]||a;return n?i.createElement(m,l(l({ref:t},p),{},{components:n})):i.createElement(m,l({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var h=2;h<a;h++)l[h]=n[h];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6310:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return h},toc:function(){return p},default:function(){return c}});var i=n(7462),r=n(3366),a=(n(7294),n(3905)),l=["components"],o={sidebar_position:2},s="How it works",h={unversionedId:"howitworks",id:"howitworks",isDocsHomePage:!1,title:"How it works",description:"Inserting identities",source:"@site/docs/howitworks.md",sourceDirName:".",slug:"/howitworks",permalink:"/semaphore-spec/howitworks",editUrl:"https://github.com/akinovak/semaphore-spec/edit/main/docs/howitworks.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/semaphore-spec/"},next:{title:"Quick start",permalink:"/semaphore-spec/quickstart"}},p=[{value:"Inserting identities",id:"inserting-identities",children:[]},{value:"Broadcasting signals",id:"broadcasting-signals",children:[{value:"The zk-SNARK circuit",id:"the-zk-snark-circuit",children:[]},{value:"That the identity commitment exists in the Merkle tree",id:"that-the-identity-commitment-exists-in-the-merkle-tree",children:[]},{value:"That the signal was only broadcasted once",id:"that-the-signal-was-only-broadcasted-once",children:[]},{value:"That the signal was truly broadcasted by the user who generated the proof",id:"that-the-signal-was-truly-broadcasted-by-the-user-who-generated-the-proof",children:[]}]},{value:"Cryptographic primitives",id:"cryptographic-primitives",children:[]}],u={toc:p};function c(e){var t=e.components,n=(0,r.Z)(e,l);return(0,a.kt)("wrapper",(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"how-it-works"},"How it works"),(0,a.kt)("h2",{id:"inserting-identities"},"Inserting identities"),(0,a.kt)("p",null,"An identity is comprised of the following information:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"An ",(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/EdDSA"},"EdDSA")," private key. Note that it is\n",(0,a.kt)("em",{parentName:"li"},"not")," an Ethereum private key."),(0,a.kt)("li",{parentName:"ol"},"An identity nullifier, whih is a random 32-byte value."),(0,a.kt)("li",{parentName:"ol"},"An identity trapdoor, whih is a random 32-byte value.")),(0,a.kt)("p",null,"An identity commitment is the Pedersen hash of:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The public key associated with the identity's private key."),(0,a.kt)("li",{parentName:"ol"},"The identity nullifier."),(0,a.kt)("li",{parentName:"ol"},"The identity trapdoor.")),(0,a.kt)("p",null,"To register an identity, the user must insert their identity commitment into\nSemaphore's identity tree. They can do this by calling the Semaphore contract's\n",(0,a.kt)("inlineCode",{parentName:"p"},"insertIdentity(uint256 _identityCommitment)")," function. See the ",(0,a.kt)("a",{parentName:"p",href:"./contract-api"},"API\nreference")," for more information."),(0,a.kt)("h2",{id:"broadcasting-signals"},"Broadcasting signals"),(0,a.kt)("p",null,"To broadcast a signal, the user must invoke this Semaphore contract function:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"broadcastSignal(\n    bytes memory _signal,\n    uint256[8] memory _proof,\n    uint256 _root,\n    uint256 _nullifiersHash,\n    uint232 _externalNullifier\n)\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_signal"),": the signal to broadcast."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_proof"),": a zk-SNARK proof (see below)."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_root"),": The root of the identity tree, where the user's identity commitment\nis the last-inserted leaf."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_nullifiersHash"),": A uniquely derived hash of the external nullifier, user's\nidentity nullifier, and the Merkle path index to their identity commitment.\nIt ensures that a user cannot broadcast a signal with the same external\nnullifier more than once."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"_externalNullifier"),": The external nullifier at which the signal is\nbroadcast.")),(0,a.kt)("p",null,"To zk-SNARK proof must satisfy the constraints created by Semaphore's zk-SNARK\ncircuit as described below:"),(0,a.kt)("h3",{id:"the-zk-snark-circuit"},"The zk-SNARK circuit"),(0,a.kt)("p",null,"The\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/semaphore/blob/master/circuits/circom/semaphore-base.circom"},"semaphore-base.circom"),"\ncircuit helps to prove the following:"),(0,a.kt)("h3",{id:"that-the-identity-commitment-exists-in-the-merkle-tree"},"That the identity commitment exists in the Merkle tree"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Private inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_pk"),": the user's EdDSA public key"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),": a random 32-byte value which the user should save"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor"),": a random 32-byte value which the user should save"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_elements"),": the values along the Merkle path to the\nuser's identity commitment"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index[n_levels]"),": the direction (left/right) per tree level\ncorresponding to the Merkle path to the user's identity commitment")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"root"),": The Merkle root of the identity tree")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the public key, identity nullifier, and identity trapdoor to\ngenerate an ",(0,a.kt)("strong",{parentName:"p"},"identity commitment"),". It then verifies the Merkle proof against\nthe Merkle root and the identity commitment."),(0,a.kt)("h3",{id:"that-the-signal-was-only-broadcasted-once"},"That the signal was only broadcasted once"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Private inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier"),": as above"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index"),": as above")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"external_nullifier"),": the 29-byte external nullifier - see above"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"nullifiers_hash"),": the hash of the identity nullifier, external nullifier,\nand Merkle path index (",(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index"),")")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the given identity nullifier, external nullifier, and Merkle\npath index, and checks that it matches the given nullifiers hash. Additionally,\nthe smart contract ensures that it has not previously seen this nullifiers\nhash. This way, double-signalling is impossible."),(0,a.kt)("h3",{id:"that-the-signal-was-truly-broadcasted-by-the-user-who-generated-the-proof"},"That the signal was truly broadcasted by the user who generated the proof"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Private inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_pk"),": as above"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"auth_sig_r"),": the ",(0,a.kt)("inlineCode",{parentName:"li"},"r")," value of the signature of the signal"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"auth_sig_s"),": the ",(0,a.kt)("inlineCode",{parentName:"li"},"s")," value of the signature of the signal")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Public inputs:")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"signal_hash"),": the hash of the signal"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"external_nullifier"),": the 29-byte external nullifier - see above")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Procedure:")),(0,a.kt)("p",null,"The circuit hashes the signal hash and the external nullifier, and verifies\nthis output against the given public key and signature. This ensures the\nauthenticity of the signal and prevents front-running attacks."),(0,a.kt)("h2",{id:"cryptographic-primitives"},"Cryptographic primitives"),(0,a.kt)("p",null,"Semaphore uses MiMC for the Merkle tree, Pedersen commmitments for the identity\ncommitments, Blake2 for the nullifiers hash, and EdDSA for the signature."),(0,a.kt)("p",null,"MiMC is a relatively new hash function. We use the recommended MiMC\nconstruction from ",(0,a.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2016/492.pdf"},"Albrecht et al"),", and\nthere is a prize to break MiMC at ",(0,a.kt)("a",{parentName:"p",href:"http://mimchash.org"},"http://mimchash.org"),"\nwhich has not been claimed yet."),(0,a.kt)("p",null,"We have also implemented a version of Semaphore which uses the Poseidon hash\nfunction for the Merkle tree and EdDSA signature verification. This may have\nbetter security than MiMC, allows identity insertions to save about 20% gas,\nand roughly halves the proving time. Note, however, that the Poseidon-related\ncircuits and EVM bytecode generator have not been audited, so use it with\ncaution. To use it, checkout the ",(0,a.kt)("inlineCode",{parentName:"p"},"feat/poseidon")," branch of this repository."))}c.isMDXComponent=!0}}]);